#!/usr/bin/env python3
"""Extract NetHack 3.6 static data from C source into Rust code.

Parses monst.c and objects.c to generate:
  - crates/nethack-types/src/monster_id.rs  (MonsterId enum)
  - crates/nethack-types/src/object_id.rs   (ObjectId enum)
  - crates/nethack-data/src/monsters.rs     (MONSTERS array)
  - crates/nethack-data/src/objects.rs      (OBJECTS array)
"""

import argparse
import re
import sys
from pathlib import Path

GENERATED_HEADER = "// @generated by tools/extract_data.py \u2014 do not edit manually\n"

# ---------------------------------------------------------------------------
# S_* symbol -> display character
# ---------------------------------------------------------------------------
S_SYMBOL_MAP = {
    "S_ANT": "a", "S_BLOB": "b", "S_COCKATRICE": "c", "S_DOG": "d",
    "S_EYE": "e", "S_FELINE": "f", "S_GREMLIN": "g", "S_HUMANOID": "h",
    "S_IMP": "i", "S_JELLY": "j", "S_KOBOLD": "k", "S_LEPRECHAUN": "l",
    "S_MIMIC": "m", "S_NYMPH": "n", "S_ORC": "o", "S_PIERCER": "p",
    "S_QUADRUPED": "q", "S_RODENT": "r", "S_SPIDER": "s", "S_TRAPPER": "t",
    "S_UNICORN": "u", "S_VORTEX": "v", "S_WORM": "w", "S_XAN": "x",
    "S_LIGHT": "y", "S_ZRUTY": "z",
    "S_ANGEL": "A", "S_BAT": "B", "S_CENTAUR": "C", "S_DRAGON": "D",
    "S_ELEMENTAL": "E", "S_FUNGUS": "F", "S_GNOME": "G", "S_GIANT": "H",
    "S_JABBERWOCK": "J", "S_KOP": "K", "S_LICH": "L", "S_MUMMY": "M",
    "S_NAGA": "N", "S_OGRE": "O", "S_PUDDING": "P", "S_QUANTMECH": "Q",
    "S_RUSTMONST": "R", "S_SNAKE": "S", "S_TROLL": "T", "S_UMBER": "U",
    "S_VAMPIRE": "V", "S_WRAITH": "W", "S_XORN": "X", "S_YETI": "Y",
    "S_ZOMBIE": "Z", "S_HUMAN": "@", "S_GHOST": " ", "S_GOLEM": "'",
    "S_DEMON": "&", "S_EEL": ";", "S_LIZARD": ":",
    "S_WORM_TAIL": "~", "S_MIMIC_DEF": "]",
}

# ---------------------------------------------------------------------------
# AT_* -> AttackType variant
# ---------------------------------------------------------------------------
AT_MAP = {
    "AT_NONE": "None", "AT_CLAW": "Claw", "AT_BITE": "Bite", "AT_KICK": "Kick",
    "AT_BUTT": "Butt", "AT_TUCH": "Touch", "AT_STNG": "Sting", "AT_HUGS": "Hugs",
    "AT_SPIT": "Spit", "AT_ENGL": "Engulf", "AT_BREA": "Breath",
    "AT_EXPL": "Explode", "AT_BOOM": "Boom", "AT_GAZE": "Gaze",
    "AT_TENT": "Tentacle", "AT_WEAP": "Weapon", "AT_MAGC": "Magic",
}

# ---------------------------------------------------------------------------
# AD_* -> DamageType variant
# ---------------------------------------------------------------------------
AD_MAP = {
    "AD_PHYS": "Physical", "AD_MAGM": "MagicMissile", "AD_FIRE": "Fire",
    "AD_COLD": "Cold", "AD_SLEE": "Sleep", "AD_DISN": "Disintegration",
    "AD_ELEC": "Electric", "AD_DRST": "DrainStr", "AD_ACID": "Acid",
    "AD_SPC1": "Spc1", "AD_SPC2": "Spc2", "AD_BLND": "Blind",
    "AD_STUN": "Stun", "AD_SLOW": "Slow", "AD_PLYS": "Paralyze",
    "AD_DRLI": "DrainLife", "AD_DREN": "DrainEnergy", "AD_LEGS": "Legs",
    "AD_STON": "Stone", "AD_STCK": "Stick", "AD_SGLD": "StealGold",
    "AD_SITM": "StealItem", "AD_SEDU": "Seduce", "AD_TLPT": "Teleport",
    "AD_RUST": "Rust", "AD_CONF": "Confuse", "AD_DGST": "Digest",
    "AD_HEAL": "Heal", "AD_WRAP": "Wrap", "AD_WERE": "Were",
    "AD_DRDX": "DrainDex", "AD_DRCO": "DrainCon", "AD_DRIN": "DrainInt",
    "AD_DISE": "Disease", "AD_DCAY": "Decay", "AD_SSEX": "SuccubusSeduction",
    "AD_HALU": "Hallucination", "AD_DETH": "Death", "AD_PEST": "Pestilence",
    "AD_FAMN": "Famine", "AD_SLIM": "Slime", "AD_ENCH": "Disenchant",
    "AD_CORR": "Corrode", "AD_CLRC": "Clerical", "AD_SPEL": "Spell",
    "AD_RBRE": "RandomBreath", "AD_SAMU": "StealAmulet", "AD_CURS": "Curse",
}

# ---------------------------------------------------------------------------
# MS_* -> MonsterSound variant
# ---------------------------------------------------------------------------
MS_MAP = {
    "MS_SILENT": "Silent", "MS_BARK": "Bark", "MS_MEW": "Mew",
    "MS_ROAR": "Roar", "MS_GROWL": "Growl", "MS_SQEEK": "Squeak",
    "MS_SQAWK": "Squawk", "MS_HISS": "Hiss", "MS_BUZZ": "Buzz",
    "MS_GRUNT": "Grunt", "MS_ORC": "Grunt", "MS_NEIGH": "Neigh",
    "MS_WAIL": "Wail", "MS_GURGLE": "Gurgle", "MS_BURBLE": "Burble",
    "MS_SHRIEK": "Shriek", "MS_BONES": "Bones", "MS_LAUGH": "Laugh",
    "MS_MUMBLE": "Mumble", "MS_IMITATE": "Imitate",
    "MS_HUMANOID": "Humanoid", "MS_ARREST": "Arrest",
    "MS_SOLDIER": "Soldier", "MS_GUARD": "Guard", "MS_DJINNI": "Djinni",
    "MS_NURSE": "Nurse", "MS_SEDUCE": "SeduceSound",
    "MS_VAMPIRE": "Vampire", "MS_BRIBE": "Bribe", "MS_CUSS": "Cuss",
    "MS_RIDER": "Rider", "MS_LEADER": "Leader", "MS_NEMESIS": "Nemesis",
    "MS_GUARDIAN": "Guardian", "MS_SELL": "Sell", "MS_ORACLE": "Oracle",
    "MS_PRIEST": "Priest", "MS_SPELL": "Spell", "MS_WERE": "Were",
    "MS_BOAST": "Boast", "MS_FERRY": "Humanoid",
}

# ---------------------------------------------------------------------------
# MZ_* -> MonsterSize variant
# ---------------------------------------------------------------------------
MZ_MAP = {
    "MZ_TINY": "Tiny", "MZ_SMALL": "Small", "MZ_MEDIUM": "Medium",
    "MZ_LARGE": "Large", "MZ_HUGE": "Huge", "MZ_GIGANTIC": "Gigantic",
    "MZ_HUMAN": "Medium",
}

# ---------------------------------------------------------------------------
# CLR_*/HI_* -> Color variant
# ---------------------------------------------------------------------------
COLOR_MAP = {
    "CLR_BLACK": "Black", "CLR_RED": "Red", "CLR_GREEN": "Green",
    "CLR_BROWN": "Brown", "CLR_BLUE": "Blue", "CLR_MAGENTA": "Magenta",
    "CLR_CYAN": "Cyan", "CLR_GRAY": "Gray",
    "CLR_BRIGHT_GREEN": "BrightGreen", "CLR_YELLOW": "Yellow",
    "CLR_BRIGHT_BLUE": "BrightBlue", "CLR_BRIGHT_MAGENTA": "BrightMagenta",
    "CLR_BRIGHT_CYAN": "BrightCyan", "CLR_WHITE": "White",
    "CLR_ORANGE": "Orange",
    "HI_DOMESTIC": "White", "HI_LORD": "Magenta",
    "HI_METAL": "Cyan", "HI_COPPER": "Yellow", "HI_SILVER": "Gray",
    "HI_GOLD": "Yellow", "HI_LEATHER": "Brown", "HI_CLOTH": "Brown",
    "HI_ORGANIC": "Brown", "HI_WOOD": "Brown", "HI_PAPER": "White",
    "HI_GLASS": "BrightCyan", "HI_MINERAL": "Gray",
    "DRAGON_SILVER": "BrightCyan",
    "HI_OBJ": "Magenta", "HI_ZAP": "BrightBlue",
}

# ---------------------------------------------------------------------------
# Material name -> Rust variant
# ---------------------------------------------------------------------------
MATERIAL_MAP = {
    "LIQUID": "Liquid", "WAX": "Wax", "VEGGY": "Veggy", "FLESH": "Flesh",
    "PAPER": "Paper", "CLOTH": "Cloth", "LEATHER": "Leather", "WOOD": "Wood",
    "BONE": "Bone", "DRAGON_HIDE": "DragonHide", "IRON": "Iron",
    "METAL": "Metal", "COPPER": "Copper", "SILVER": "Silver", "GOLD": "Gold",
    "PLATINUM": "Platinum", "MITHRIL": "Mithril", "PLASTIC": "Plastic",
    "GLASS": "Glass", "GEMSTONE": "Gemstone", "MINERAL": "Mineral",
    "0": "Liquid",
}

# ---------------------------------------------------------------------------
# Object class name -> Rust variant
# ---------------------------------------------------------------------------
OBJCLASS_MAP = {
    "ILLOBJ_CLASS": "IllObj", "WEAPON_CLASS": "Weapon", "ARMOR_CLASS": "Armor",
    "RING_CLASS": "Ring", "AMULET_CLASS": "Amulet", "TOOL_CLASS": "Tool",
    "FOOD_CLASS": "Food", "POTION_CLASS": "Potion", "SCROLL_CLASS": "Scroll",
    "SPBOOK_CLASS": "SpellBook", "WAND_CLASS": "Wand", "COIN_CLASS": "Coin",
    "GEM_CLASS": "Gem", "ROCK_CLASS": "Rock", "BALL_CLASS": "Ball",
    "CHAIN_CLASS": "Chain", "VENOM_CLASS": "Venom",
}

# ---------------------------------------------------------------------------
# P_* weapon skill constants
# ---------------------------------------------------------------------------
P_SKILL = {
    "P_NONE": 0, "P_DAGGER": 1, "P_KNIFE": 2, "P_AXE": 3, "P_PICK_AXE": 4,
    "P_SHORT_SWORD": 5, "P_BROAD_SWORD": 6, "P_LONG_SWORD": 7,
    "P_TWO_HANDED_SWORD": 8, "P_SCIMITAR": 9, "P_SABER": 10,
    "P_CLUB": 11, "P_MACE": 12, "P_MORNING_STAR": 13, "P_FLAIL": 14,
    "P_HAMMER": 15, "P_QUARTERSTAFF": 16, "P_POLEARMS": 17, "P_SPEAR": 18,
    "P_TRIDENT": 19, "P_LANCE": 20, "P_BOW": 21, "P_SLING": 22,
    "P_CROSSBOW": 23, "P_DART": 24, "P_SHURIKEN": 25, "P_BOOMERANG": 26,
    "P_WHIP": 27, "P_UNICORN_HORN": 28,
    "P_ATTACK_SPELL": 29, "P_HEALING_SPELL": 30, "P_DIVINATION_SPELL": 31,
    "P_ENCHANTMENT_SPELL": 32, "P_CLERIC_SPELL": 33, "P_ESCAPE_SPELL": 34,
    "P_MATTER_SPELL": 35,
}

# Armor sub-types
ARM_SUIT = 0
ARM_SHIELD = 1
ARM_HELM = 2
ARM_GLOVES = 3
ARM_BOOTS = 4
ARM_CLOAK = 5
ARM_SHIRT = 6

# Direction constants
DIR_MAP = {
    "NODIR": 1, "IMMEDIATE": 2, "RAY": 3,
    # Weapon hit types also stored in the dir field
    "WHACK": 0, "B": 0, "PIERCE": 1, "P": 1, "SLASH": 2, "S": 2,
}

# Weapon type shorthand
WEPTYPE_MAP = {"P": 1, "S": 2, "B": 0, "PIERCE": 1, "SLASH": 2, "WHACK": 0}

# Property constant -> u8 value (matching the Rust Property enum)
PROPERTY_MAP = {
    "0": 0,
    "FIRE_RES": 1, "COLD_RES": 2, "SLEEP_RES": 3, "DISINT_RES": 4,
    "SHOCK_RES": 5, "POISON_RES": 6, "ACID_RES": 7, "STONE_RES": 8,
    "DRAIN_RES": 9, "SICK_RES": 10, "INVULNERABLE": 11, "ANTIMAGIC": 12,
    "STUNNED": 13, "CONFUSION": 14, "BLINDED": 15, "DEAF": 16,
    "SICK": 17, "STONED": 18, "STRANGLED": 19, "VOMITING": 20,
    "GLIB": 21, "SLIMED": 22, "HALLUC": 23, "HALLUC_RES": 24,
    "FUMBLING": 25, "WOUNDED_LEGS": 26, "SLEEPY": 27, "HUNGER": 28,
    "SEE_INVIS": 29, "TELEPAT": 30, "WARNING": 31, "WARN_OF_MON": 32,
    "WARN_UNDEAD": 33, "SEARCHING": 34, "CLAIRVOYANT": 35,
    "INFRAVISION": 36, "DETECT_MONSTERS": 37,
    "ADORNED": 38, "INVIS": 39, "DISPLACED": 40, "STEALTH": 41,
    "AGGRAVATE_MONSTER": 42, "CONFLICT": 43,
    "JUMPING": 44, "TELEPORT": 45, "TELEPORT_CONTROL": 46,
    "LEVITATION": 47, "FLYING": 48, "WWALKING": 49, "SWIMMING": 50,
    "MAGICAL_BREATHING": 51, "PASSES_WALLS": 52,
    "SLOW_DIGESTION": 53, "HALF_SPDAM": 54, "HALF_PHDAM": 55,
    "REGENERATION": 56, "ENERGY_REGENERATION": 57,
    "PROTECTION": 58, "PROT_FROM_SHAPE_CHANGERS": 59,
    "POLYMORPH": 60, "POLYMORPH_CONTROL": 61, "UNCHANGING": 62,
    "FAST": 63, "REFLECTING": 64, "FREE_ACTION": 65, "FIXED_ABIL": 66,
    "LIFESAVED": 67,
}

# Resistance flags
MR_FLAGS = {
    "MR_FIRE": 0x01, "MR_COLD": 0x02, "MR_SLEEP": 0x04,
    "MR_DISINT": 0x08, "MR_ELEC": 0x10, "MR_POISON": 0x20,
    "MR_ACID": 0x40, "MR_STONE": 0x80,
}

# M1, M2, M3 flags
M1_FLAGS = {
    "M1_FLY": 0x1, "M1_SWIM": 0x2, "M1_AMORPHOUS": 0x4,
    "M1_WALLWALK": 0x8, "M1_CLING": 0x10, "M1_TUNNEL": 0x20,
    "M1_NEEDPICK": 0x40, "M1_CONCEAL": 0x80, "M1_HIDE": 0x100,
    "M1_AMPHIBIOUS": 0x200, "M1_BREATHLESS": 0x400, "M1_NOTAKE": 0x800,
    "M1_NOEYES": 0x1000, "M1_NOHANDS": 0x2000, "M1_NOLIMBS": 0x6000,
    "M1_NOHEAD": 0x8000, "M1_MINDLESS": 0x10000, "M1_HUMANOID": 0x20000,
    "M1_ANIMAL": 0x40000, "M1_SLITHY": 0x80000, "M1_UNSOLID": 0x100000,
    "M1_THICK_HIDE": 0x200000, "M1_OVIPAROUS": 0x400000,
    "M1_REGEN": 0x800000, "M1_SEE_INVIS": 0x1000000,
    "M1_TPORT": 0x2000000, "M1_TPORT_CNTRL": 0x4000000,
    "M1_ACID": 0x8000000, "M1_POIS": 0x10000000,
    "M1_CARNIVORE": 0x20000000, "M1_HERBIVORE": 0x40000000,
    "M1_OMNIVORE": 0x60000000, "M1_METALLIVORE": 0x80000000,
}

M2_FLAGS = {
    "M2_NOPOLY": 0x1, "M2_UNDEAD": 0x2, "M2_WERE": 0x4,
    "M2_HUMAN": 0x8, "M2_ELF": 0x10, "M2_DWARF": 0x20,
    "M2_GNOME": 0x40, "M2_ORC": 0x80, "M2_DEMON": 0x100,
    "M2_MERC": 0x200, "M2_LORD": 0x400, "M2_PRINCE": 0x800,
    "M2_MINION": 0x1000, "M2_GIANT": 0x2000,
    "M2_SHAPESHIFTER": 0x4000,
    "M2_MALE": 0x10000, "M2_FEMALE": 0x20000, "M2_NEUTER": 0x40000,
    "M2_PNAME": 0x80000, "M2_HOSTILE": 0x100000,
    "M2_PEACEFUL": 0x200000, "M2_DOMESTIC": 0x400000,
    "M2_WANDER": 0x800000, "M2_STALK": 0x1000000,
    "M2_NASTY": 0x2000000, "M2_STRONG": 0x4000000,
    "M2_ROCKTHROW": 0x8000000, "M2_GREEDY": 0x10000000,
    "M2_JEWELS": 0x20000000, "M2_COLLECT": 0x40000000,
    "M2_MAGIC": 0x80000000,
}

M3_FLAGS = {
    "M3_WANTSAMUL": 0x1, "M3_WANTSBELL": 0x2, "M3_WANTSBOOK": 0x4,
    "M3_WANTSCAND": 0x8, "M3_WANTSARTI": 0x10, "M3_WANTSALL": 0x1F,
    "M3_WAITFORU": 0x40, "M3_CLOSE": 0x80,
    "M3_COVETOUS": 0x1F, "M3_WAITMASK": 0xC0,
    "M3_INFRAVISION": 0x100, "M3_INFRAVISIBLE": 0x200,
    "M3_DISPLACES": 0x400,
}

G_FLAGS = {
    "G_UNIQ": 0x1000, "G_NOHELL": 0x800, "G_HELL": 0x400,
    "G_NOGEN": 0x200, "G_SGROUP": 0x80, "G_LGROUP": 0x40,
    "G_GENO": 0x20, "G_NOCORPSE": 0x10,
}

# Weight constants used in monst.c
WT_CONSTANTS = {
    "WT_ELF": 800,
    "WT_DRAGON": 4500,
    "WT_HUMAN": 1450,
    "A_NONE": 0,
    "WHACK": 0,
    "PIERCE": 1,
    "SLASH": 2,
}

# Text substitutions to expand inline macros before parsing
INLINE_MACROS = {
    "SEDUCTION_ATTACKS_YES": "A(ATTK(AT_BITE, AD_SSEX, 0, 0), ATTK(AT_CLAW, AD_PHYS, 1, 3), ATTK(AT_CLAW, AD_PHYS, 1, 3), NO_ATTK, NO_ATTK, NO_ATTK)",
    "SEDUCTION_ATTACKS_NO": "A(ATTK(AT_CLAW, AD_PHYS, 1, 3), ATTK(AT_CLAW, AD_PHYS, 1, 3), ATTK(AT_BITE, AD_DRLI, 2, 6), NO_ATTK, NO_ATTK, NO_ATTK)",
}


# ============================================================================
# Preprocessing: strip comments, #if 0 blocks, join continuations
# ============================================================================

def strip_c_comments(text):
    """Remove C-style /* ... */ and // ... comments."""
    # Remove block comments (non-greedy, handles multiline)
    text = re.sub(r'/\*.*?\*/', ' ', text, flags=re.DOTALL)
    # Remove line comments
    text = re.sub(r'//[^\n]*', '', text)
    return text


def strip_if0_blocks(text):
    """Remove #if 0 ... #endif blocks, handling nesting."""
    lines = text.split('\n')
    result = []
    skip_depth = 0
    for line in lines:
        stripped = line.strip()
        if skip_depth > 0:
            # Inside a skipped block
            if stripped.startswith('#if'):
                skip_depth += 1
            elif stripped.startswith('#endif'):
                skip_depth -= 1
            # Don't add any lines while skipping
            continue
        # Check for #if 0
        if re.match(r'^#if\s+0\b', stripped):
            skip_depth = 1
            continue
        result.append(line)
    return '\n'.join(result)


def strip_preprocessor_conditionals(text):
    """Remove #ifdef/#ifndef/#else/#endif for SPLITMON, MAIL, etc.

    Keep content from all branches except #if 0 (already handled).
    """
    lines = text.split('\n')
    result = []
    for line in lines:
        stripped = line.strip()
        # Skip preprocessor directives that aren't defines we need
        if re.match(r'^#\s*(ifdef|ifndef|else|endif|if\s+defined|elif)\b', stripped):
            continue
        if re.match(r'^#\s*(undef|define)\s+(WEAPON|PROJECTILE|BOW|ARMOR|HELM|CLOAK|SHIELD|GLOVES|BOOTS|RING|AMULET|TOOL|CONTAINER|WEPTOOL|FOOD|POTION|SCROLL|SPELL|WAND|COIN|GEM|ROCK|DRGN_ARMR|P|S|B|PAPER)\b', stripped):
            continue
        if re.match(r'^#\s*include\b', stripped):
            continue
        result.append(line)
    return '\n'.join(result)


def join_continuation_lines(text):
    """Join lines ending with backslash."""
    lines = text.split('\n')
    result = []
    accumulating = ""
    for line in lines:
        if line.rstrip().endswith('\\'):
            accumulating += line.rstrip()[:-1] + " "
        else:
            if accumulating:
                accumulating += line
                result.append(accumulating)
                accumulating = ""
            else:
                result.append(line)
    if accumulating:
        result.append(accumulating)
    return '\n'.join(result)


def expand_inline_macros(text):
    """Expand known inline macros (e.g. SEDUCTION_ATTACKS_YES) in place."""
    for name, expansion in INLINE_MACROS.items():
        text = re.sub(r'\b' + re.escape(name) + r'\b', expansion, text)
    return text


def preprocess(text):
    """Full preprocessing pipeline.

    Join continuation lines BEFORE stripping preprocessor directives so that
    multi-line #define bodies become single lines and get fully removed.
    """
    text = strip_c_comments(text)
    text = join_continuation_lines(text)
    # CHARON is not defined in the NetHack build, so treat #ifdef CHARON
    # blocks the same as #if 0 (exclude their content).
    text = re.sub(r'^#\s*ifdef\s+CHARON\b', '#if 0', text, flags=re.MULTILINE)
    text = strip_if0_blocks(text)
    text = strip_preprocessor_conditionals(text)
    text = expand_inline_macros(text)
    return text


# ============================================================================
# Bracket-aware argument extraction
# ============================================================================

def find_matching_paren(text, start):
    """Find the closing ')' that matches the '(' at position start."""
    depth = 0
    i = start
    in_string = False
    escape = False
    while i < len(text):
        ch = text[i]
        if escape:
            escape = False
            i += 1
            continue
        if ch == '\\':
            escape = True
            i += 1
            continue
        if ch == '"' and not in_string:
            in_string = True
            i += 1
            continue
        if ch == '"' and in_string:
            in_string = False
            i += 1
            continue
        if in_string:
            i += 1
            continue
        if ch == '(':
            depth += 1
        elif ch == ')':
            depth -= 1
            if depth == 0:
                return i
        i += 1
    return -1


def split_args(text):
    """Split a comma-separated argument list respecting nested parens and strings."""
    args = []
    depth = 0
    current = ""
    in_string = False
    escape = False
    for ch in text:
        if escape:
            current += ch
            escape = False
            continue
        if ch == '\\':
            current += ch
            escape = True
            continue
        if ch == '"' and not in_string:
            in_string = True
            current += ch
            continue
        if ch == '"' and in_string:
            in_string = False
            current += ch
            continue
        if in_string:
            current += ch
            continue
        if ch == '(':
            depth += 1
            current += ch
        elif ch == ')':
            depth -= 1
            current += ch
        elif ch == ',' and depth == 0:
            args.append(current.strip())
            current = ""
        else:
            current += ch
    if current.strip():
        args.append(current.strip())
    return args


def normalize_ws(s):
    """Collapse whitespace to single spaces and strip."""
    return re.sub(r'\s+', ' ', s).strip()


def extract_macro_calls(text, macro_name):
    """Find all top-level MACRO(...) calls and return their argument strings.

    Skips matches that appear on #define lines to avoid parsing macro
    definitions as data invocations.
    """
    results = []
    pattern = re.compile(r'\b' + re.escape(macro_name) + r'\s*\(')
    pos = 0
    while pos < len(text):
        m = pattern.search(text, pos)
        if not m:
            break
        # Skip if this match is on a #define line
        line_start = text.rfind('\n', 0, m.start()) + 1
        line_prefix = text[line_start:m.start()].strip()
        if line_prefix.startswith('#'):
            pos = m.end()
            continue
        paren_start = m.end() - 1  # position of '('
        paren_end = find_matching_paren(text, paren_start)
        if paren_end < 0:
            pos = m.end()
            continue
        inner = text[paren_start + 1:paren_end]
        results.append(normalize_ws(inner))
        pos = paren_end + 1
    return results


# ============================================================================
# Name -> PascalCase conversion
# ============================================================================

def to_pascal_case(name):
    """Convert a NetHack name to a PascalCase Rust identifier."""
    if not name:
        return ""
    # Remove apostrophes, replace hyphens with spaces for word splitting
    s = name.replace("'", "").replace("-", " ")
    # Split on spaces and capitalize each word
    words = s.split()
    result = ""
    for w in words:
        if w:
            result += w[0].upper() + w[1:]
    # Ensure it starts with a letter
    if result and not result[0].isalpha():
        result = "X" + result
    return result


def deduplicate_names(names_with_ctx):
    """Given list of (name, class_hint), return unique PascalCase names.

    class_hint is used for disambiguation when there are duplicates.
    """
    pascal_names = [(to_pascal_case(n), c) for n, c in names_with_ctx]
    # Check for duplicates
    seen = {}
    for i, (pn, _) in enumerate(pascal_names):
        if pn in seen:
            seen[pn].append(i)
        else:
            seen[pn] = [i]

    result = list(pascal_names)
    for pn, indices in seen.items():
        if len(indices) > 1:
            # Keep first occurrence with no hint as-is; prefix others
            has_plain = False
            for idx in indices:
                _, cls = pascal_names[idx]
                if cls:
                    new_name = cls + pn
                    result[idx] = (new_name, cls)
                elif not has_plain:
                    has_plain = True
                    # Keep the first unhinted one unchanged
                else:
                    new_name = pn + str(idx)
                    result[idx] = (new_name, cls)

    # Final dedup pass in case the class-prefixed names still collide
    final_seen = {}
    final_result = []
    for pn, cls in result:
        if pn in final_seen:
            final_seen[pn] += 1
            pn = pn + str(final_seen[pn])
        else:
            final_seen[pn] = 1
        final_result.append(pn)
    return final_result


# ============================================================================
# Evaluate flag/constant expressions
# ============================================================================

def eval_flags(expr, flag_map):
    """Evaluate a C flag expression like 'M1_ANIMAL | M1_NOHANDS | M1_CARNIVORE'."""
    expr = expr.strip()
    if expr in ('0', '0L', '0l'):
        return 0
    value = 0
    parts = [p.strip() for p in expr.split('|')]
    for part in parts:
        part = part.strip()
        if part in ('0', '0L', '0l', ''):
            continue
        if part in flag_map:
            value |= flag_map[part]
        elif part.startswith('0x'):
            value |= int(part, 16)
        elif part.isdigit():
            value |= int(part)
        else:
            print(f"  WARNING: Unknown flag '{part}' in expression '{expr}'", file=sys.stderr)
    return value


def eval_geno(expr):
    """Evaluate geno flags expression, which can include frequency bits."""
    expr = expr.strip()
    if expr.startswith('(') and expr.endswith(')'):
        expr = expr[1:-1].strip()
    value = 0
    parts = [p.strip() for p in expr.split('|')]
    for part in parts:
        part = part.strip()
        if part in ('0', '0L', '0l', ''):
            continue
        if part in G_FLAGS:
            value |= G_FLAGS[part]
        elif part.isdigit():
            value |= int(part)
        elif part.startswith('0x'):
            value |= int(part, 16)
        else:
            print(f"  WARNING: Unknown geno flag '{part}'", file=sys.stderr)
    return value


def eval_int(expr):
    """Evaluate a simple integer expression (may include WT_* constants)."""
    expr = expr.strip()
    if expr in ('0', '0L', '0l'):
        return 0
    if expr in WT_CONSTANTS:
        return WT_CONSTANTS[expr]
    # Handle negative
    if expr.startswith('-'):
        return -eval_int(expr[1:])
    # Handle P_* skill references
    if expr in P_SKILL:
        return P_SKILL[expr]
    # Handle -P_* references
    m = re.match(r'^-\s*(P_\w+)$', expr)
    if m and m.group(1) in P_SKILL:
        return -P_SKILL[m.group(1)]
    try:
        return int(expr)
    except ValueError:
        print(f"  WARNING: Cannot evaluate integer expression '{expr}'", file=sys.stderr)
        return 0


def eval_weptype(expr):
    """Evaluate weapon type like P, S, B, P|S."""
    expr = expr.strip()
    if expr in ('0', '0L'):
        return 0
    parts = [p.strip() for p in expr.split('|')]
    value = 0
    for p in parts:
        if p in WEPTYPE_MAP:
            value |= WEPTYPE_MAP[p]
        elif p.isdigit():
            value |= int(p)
        else:
            print(f"  WARNING: Unknown weapon type '{p}'", file=sys.stderr)
    return value


def eval_property(expr):
    """Evaluate a property constant."""
    expr = expr.strip()
    if expr in ('0', '0L'):
        return 0
    if expr in PROPERTY_MAP:
        return PROPERTY_MAP[expr]
    try:
        return int(expr)
    except ValueError:
        print(f"  WARNING: Unknown property '{expr}'", file=sys.stderr)
        return 0


def eval_sub_type(expr):
    """Evaluate object sub_type (P_* skill, possibly negative, or ARM_*)."""
    expr = expr.strip()
    if expr in ('0', '0L'):
        return 0
    arm_map = {
        "ARM_SUIT": 0, "ARM_SHIELD": 1, "ARM_HELM": 2, "ARM_GLOVES": 3,
        "ARM_BOOTS": 4, "ARM_CLOAK": 5, "ARM_SHIRT": 6,
    }
    if expr in arm_map:
        return arm_map[expr]
    if expr in P_SKILL:
        return P_SKILL[expr]
    if expr.startswith('-'):
        inner = expr[1:].strip()
        if inner in P_SKILL:
            return -P_SKILL[inner]
    try:
        return int(expr)
    except ValueError:
        print(f"  WARNING: Cannot evaluate sub_type '{expr}'", file=sys.stderr)
        return 0


def eval_dir(expr):
    """Evaluate direction constant (or weapon hit type like P|S)."""
    expr = expr.strip()
    if expr in ('0', '0L'):
        return 0
    if expr in DIR_MAP:
        return DIR_MAP[expr]
    # Handle bitwise OR for compound weapon types like P|S, B|P
    if '|' in expr:
        value = 0
        for part in expr.split('|'):
            part = part.strip()
            if part in DIR_MAP:
                value |= DIR_MAP[part]
            elif part.isdigit():
                value |= int(part)
            else:
                print(f"  WARNING: Unknown direction part '{part}'", file=sys.stderr)
        return value
    try:
        return int(expr)
    except ValueError:
        print(f"  WARNING: Unknown direction '{expr}'", file=sys.stderr)
        return 0


def hardgem(mohs):
    """HARDGEM(n) = (n >= 8) ? 1 : 0"""
    return 1 if mohs >= 8 else 0


# ============================================================================
# Monster parsing
# ============================================================================

def parse_attack(attk_str):
    """Parse ATTK(at, ad, n, d) or NO_ATTK."""
    attk_str = attk_str.strip()
    if attk_str == "NO_ATTK":
        return None
    # Handle {0, 0, 0, 0} form (from NO_ATTK expansion after preprocessing)
    m = re.match(r'^\{\s*0\s*,\s*0\s*,\s*0\s*,\s*0\s*\}$', attk_str)
    if m:
        return None
    # ATTK(at, ad, n, d)
    m = re.match(r'^ATTK\s*\((.+)\)$', attk_str)
    if m:
        parts = split_args(m.group(1))
        if len(parts) != 4:
            print(f"  WARNING: ATTK has {len(parts)} args: {attk_str}", file=sys.stderr)
            return None
        at = parts[0].strip()
        ad = parts[1].strip()
        n = eval_int(parts[2])
        d = eval_int(parts[3])
        return (at, ad, n, d)
    print(f"  WARNING: Cannot parse attack '{attk_str}'", file=sys.stderr)
    return None


def parse_attacks(a_str):
    """Parse A(attk1, attk2, ..., attk6)."""
    a_str = a_str.strip()
    m = re.match(r'^A\s*\((.+)\)$', a_str)
    if not m:
        # Try bare brace form
        m = re.match(r'^\{(.+)\}$', a_str)
        if not m:
            print(f"  WARNING: Cannot parse attacks '{a_str}'", file=sys.stderr)
            return [None] * 6
    inner = m.group(1)
    parts = split_args(inner)
    attacks = []
    for p in parts:
        attacks.append(parse_attack(p.strip()))
    while len(attacks) < 6:
        attacks.append(None)
    return attacks[:6]


def parse_lvl(lvl_str):
    """Parse LVL(lvl, mov, ac, mr, aln) — returns the 5 individual args."""
    lvl_str = lvl_str.strip()
    m = re.match(r'^LVL\s*\((.+)\)$', lvl_str)
    if not m:
        print(f"  WARNING: Cannot parse LVL '{lvl_str}'", file=sys.stderr)
        return (0, 0, 0, 0, 0)
    parts = split_args(m.group(1))
    if len(parts) != 5:
        print(f"  WARNING: LVL has {len(parts)} args", file=sys.stderr)
        return (0, 0, 0, 0, 0)
    return tuple(eval_int(p) for p in parts)


def parse_siz(siz_str):
    """Parse SIZ(wt, nut, snd, siz) — returns (weight, nutrition, sound, size)."""
    siz_str = siz_str.strip()
    m = re.match(r'^SIZ\s*\((.+)\)$', siz_str)
    if not m:
        print(f"  WARNING: Cannot parse SIZ '{siz_str}'", file=sys.stderr)
        return (0, 0, "MS_SILENT", "MZ_TINY")
    parts = split_args(m.group(1))
    if len(parts) != 4:
        print(f"  WARNING: SIZ has {len(parts)} args", file=sys.stderr)
        return (0, 0, "MS_SILENT", "MZ_TINY")
    wt = eval_int(parts[0])
    nut = eval_int(parts[1])
    snd = parts[2].strip()
    siz = parts[3].strip()
    return (wt, nut, snd, siz)


def extract_string(s):
    """Extract a C string literal value, or return None for 'None'."""
    s = s.strip()
    if s in ('(char *) 0', 'None', '0', 'NULL'):
        return None
    m = re.match(r'^"(.*)"$', s)
    if m:
        return m.group(1)
    print(f"  WARNING: Cannot extract string from '{s}'", file=sys.stderr)
    return s


def parse_monsters(text):
    """Parse all MON() calls from preprocessed monst.c text."""
    mon_calls = extract_macro_calls(text, "MON")
    monsters = []
    for call in mon_calls:
        # MON has 13 args but some are compound (LVL, A, SIZ)
        # Split at top level
        args = split_args(call)

        # We need to handle the fact that LVL, A, SIZ are compound
        # and may have internal commas. The top-level split will expand them.
        # MON(nam, sym, LVL(...), gen, A(...), SIZ(...), mr1, mr2, flg1, flg2, flg3, d, col)
        # But since LVL/A/SIZ are macros that expand to bare comma-separated values,
        # we need a different approach.
        #
        # LVL(a,b,c,d,e) expands to: a,b,c,d,e (5 values)
        # A(a1..a6) expands to: {a1,a2,a3,a4,a5,a6} (stays as 1 arg due to braces)
        # SIZ(a,b,c,d) expands to: a,b,c,d (4 values)
        #
        # After preprocessing, a MON call looks like:
        # MON("name", S_SYM, LVL(l,m,a,mr,al), (geno), A(ATTK(...),ATTK(...),...), SIZ(w,n,s,sz), mr1, mr2, f1, f2, f3, d, CLR)
        #
        # Since LVL and SIZ are still macro calls (not expanded in our text),
        # and A is still a macro call, the bracket-aware split will keep them intact.
        # So we should get 13 args.

        if len(args) < 13:
            # Might be the terminator with fewer args
            name = extract_string(args[0]) if args else ""
            if name == "":
                continue  # Skip terminator
            print(f"  WARNING: MON has {len(args)} args for '{name}': {args}", file=sys.stderr)
            continue

        name = extract_string(args[0])
        if name == "" or name is None:
            continue  # Skip terminator

        sym = args[1].strip()
        lvl_str = args[2].strip()
        geno_str = args[3].strip()
        attacks_str = args[4].strip()
        siz_str = args[5].strip()
        mr1_str = args[6].strip()
        mr2_str = args[7].strip()
        flg1_str = args[8].strip()
        flg2_str = args[9].strip()
        flg3_str = args[10].strip()
        diff_str = args[11].strip()
        color_str = args[12].strip()

        level, move_speed, ac, magic_resistance, alignment = parse_lvl(lvl_str)
        geno = eval_geno(geno_str)
        attacks = parse_attacks(attacks_str)
        wt, nut, snd, siz = parse_siz(siz_str)
        mr1 = eval_flags(mr1_str, MR_FLAGS)
        mr2 = eval_flags(mr2_str, MR_FLAGS)
        flg1 = eval_flags(flg1_str, M1_FLAGS)
        flg2 = eval_flags(flg2_str, M2_FLAGS)
        flg3 = eval_flags(flg3_str, M3_FLAGS)
        diff = eval_int(diff_str)
        color = color_str

        monsters.append({
            'name': name,
            'symbol': sym,
            'level': level,
            'move_speed': move_speed,
            'ac': ac,
            'magic_resistance': magic_resistance,
            'alignment': alignment,
            'geno': geno,
            'attacks': attacks,
            'corpse_weight': wt,
            'nutrition': nut,
            'sound': snd,
            'size': siz,
            'resistances': mr1,
            'conveys': mr2,
            'flags1': flg1,
            'flags2': flg2,
            'flags3': flg3,
            'difficulty': diff,
            'color': color,
        })

    return monsters


# ============================================================================
# Object parsing
# ============================================================================

def parse_obj_macro(name, args_str, text):
    """Parse an individual object wrapper macro call.

    Returns a dict with all OBJECT-level fields, or None to skip.
    """
    args = split_args(args_str)

    # The two-spell PAPER->LEATHER hack: we track this state externally
    # so this function just maps materials normally.

    if name == "OBJECT":
        return parse_bare_object(args)
    elif name == "WEAPON":
        return parse_weapon(args)
    elif name == "PROJECTILE":
        return parse_projectile(args)
    elif name == "BOW":
        return parse_bow(args)
    elif name == "ARMOR":
        return parse_armor(args)
    elif name == "HELM":
        return parse_helm(args)
    elif name == "CLOAK":
        return parse_cloak(args)
    elif name == "SHIELD":
        return parse_shield(args)
    elif name == "GLOVES":
        return parse_gloves(args)
    elif name == "BOOTS":
        return parse_boots(args)
    elif name == "DRGN_ARMR":
        return parse_drgn_armr(args)
    elif name == "RING":
        return parse_ring(args)
    elif name == "AMULET":
        return parse_amulet(args)
    elif name == "TOOL":
        return parse_tool(args)
    elif name == "CONTAINER":
        return parse_container(args)
    elif name == "WEPTOOL":
        return parse_weptool(args)
    elif name == "FOOD":
        return parse_food(args)
    elif name == "POTION":
        return parse_potion(args)
    elif name == "SCROLL":
        return parse_scroll(args)
    elif name == "SPELL":
        return parse_spell(args)
    elif name == "WAND":
        return parse_wand(args)
    elif name == "COIN":
        return parse_coin(args)
    elif name == "GEM":
        return parse_gem(args)
    elif name == "ROCK":
        return parse_rock(args)
    else:
        print(f"  WARNING: Unknown macro '{name}'", file=sys.stderr)
        return None


def make_obj(obj_name, obj_desc, bits_args, prop, obj_class, prob, delay, wt,
             cost, sdam, ldam, oc1, oc2, nutrition, color):
    """Construct a standard object dict from the OBJECT-level fields."""
    # bits_args: (nmkn, mrg, uskn, ctnr, mgc, chrg, uniq, nwsh, big, tuf, dir, sub, mtrl)
    nmkn, mrg, uskn, _ctnr, mgc, chrg, uniq, nwsh, big, tuf, d, sub, mtrl = bits_args

    return {
        'name': obj_name,
        'description': obj_desc,
        'class': obj_class,
        'sub_type': eval_sub_type(str(sub)),
        'prob': eval_int(str(prob)),
        'delay': eval_int(str(delay)),
        'weight': eval_int(str(wt)),
        'cost': eval_int(str(cost)),
        'damage_small': eval_int(str(sdam)),
        'damage_large': eval_int(str(ldam)),
        'oc1': eval_int(str(oc1)),
        'oc2': eval_int(str(oc2)),
        'material': str(mtrl),
        'color': str(color),
        'nutrition': eval_int(str(nutrition)),
        'prop': eval_property(str(prop)),
        'flags': {
            'name_known': bool(eval_int(str(nmkn))),
            'merge': bool(eval_int(str(mrg))),
            'uses_known': bool(eval_int(str(uskn))),
            'pre_discovered': False,
            'magic': bool(eval_int(str(mgc))),
            'charged': bool(eval_int(str(chrg))),
            'unique': bool(eval_int(str(uniq))),
            'no_wish': bool(eval_int(str(nwsh))),
            'big': bool(eval_int(str(big))),
            'tough': bool(eval_int(str(tuf))),
            'dir': eval_dir(str(d)),
        },
    }


def parse_bare_object(args):
    """Parse a bare OBJECT(...) call with 14 args."""
    if len(args) != 14:
        print(f"  WARNING: OBJECT has {len(args)} args: {args}", file=sys.stderr)
        return None

    obj_str = args[0].strip()
    bits_str = args[1].strip()
    prop = args[2].strip()
    obj_class = args[3].strip()
    prob = args[4].strip()
    delay = args[5].strip()
    wt = args[6].strip()
    cost = args[7].strip()
    sdam = args[8].strip()
    ldam = args[9].strip()
    oc1 = args[10].strip()
    oc2 = args[11].strip()
    nutrition = args[12].strip()
    color = args[13].strip()

    # Parse OBJ(name, desc)
    obj_name, obj_desc = parse_obj_name_desc(obj_str)

    # Check for terminator
    if obj_name is None and obj_desc is None:
        return None  # terminator

    # Parse BITS(...)
    bits = parse_bits(bits_str)

    return make_obj(obj_name, obj_desc, bits, prop, obj_class, prob, delay, wt,
                    cost, sdam, ldam, oc1, oc2, nutrition, color)


def parse_obj_name_desc(obj_str):
    """Parse OBJ(name, desc) and return (name, desc)."""
    obj_str = obj_str.strip()
    m = re.match(r'^OBJ\s*\((.+)\)$', obj_str)
    if m:
        parts = split_args(m.group(1))
        if len(parts) != 2:
            print(f"  WARNING: OBJ has {len(parts)} args: {obj_str}", file=sys.stderr)
            return (None, None)
        name = extract_string(parts[0])
        desc = extract_string(parts[1])
        return (name, desc)
    print(f"  WARNING: Cannot parse OBJ '{obj_str}'", file=sys.stderr)
    return (None, None)


def parse_bits(bits_str):
    """Parse BITS(nmkn,mrg,uskn,ctnr,mgc,chrg,uniq,nwsh,big,tuf,dir,sub,mtrl)."""
    bits_str = bits_str.strip()
    m = re.match(r'^BITS\s*\((.+)\)$', bits_str)
    if m:
        parts = split_args(m.group(1))
        if len(parts) != 13:
            print(f"  WARNING: BITS has {len(parts)} args: {bits_str}", file=sys.stderr)
            return tuple([0] * 13)
        return tuple(p.strip() for p in parts)
    print(f"  WARNING: Cannot parse BITS '{bits_str}'", file=sys.stderr)
    return tuple([0] * 13)


def parse_weapon(args):
    """WEAPON(name,desc,kn,mg,bi,prob,wt,cost,sdam,ldam,hitbon,typ,sub,metal,color)"""
    if len(args) != 15:
        print(f"  WARNING: WEAPON has {len(args)} args: {args}", file=sys.stderr)
        return None
    name = extract_string(args[0])
    desc = extract_string(args[1])
    kn, mg, bi = args[2], args[3], args[4]
    prob, wt, cost = args[5], args[6], args[7]
    sdam, ldam, hitbon = args[8], args[9], args[10]
    typ, sub, metal, color = args[11], args[12], args[13], args[14]

    bits = (kn, mg, "1", "0", "0", "1", "0", "0", bi, "0", typ, sub, metal)
    return make_obj(name, desc, bits, "0", "WEAPON_CLASS", prob, "0", wt,
                    cost, sdam, ldam, hitbon, "0", wt, color)


def parse_projectile(args):
    """PROJECTILE(name,desc,kn,prob,wt,cost,sdam,ldam,hitbon,metal,sub,color)"""
    if len(args) != 12:
        print(f"  WARNING: PROJECTILE has {len(args)} args: {args}", file=sys.stderr)
        return None
    name = extract_string(args[0])
    desc = extract_string(args[1])
    kn = args[2]
    prob, wt, cost = args[3], args[4], args[5]
    sdam, ldam, hitbon = args[6], args[7], args[8]
    metal, sub, color = args[9], args[10], args[11]

    bits = (kn, "1", "1", "0", "0", "1", "0", "0", "0", "0", "PIERCE", sub, metal)
    return make_obj(name, desc, bits, "0", "WEAPON_CLASS", prob, "0", wt,
                    cost, sdam, ldam, hitbon, "0", wt, color)


def parse_bow(args):
    """BOW(name,desc,kn,prob,wt,cost,hitbon,metal,sub,color)"""
    if len(args) != 10:
        print(f"  WARNING: BOW has {len(args)} args: {args}", file=sys.stderr)
        return None
    name = extract_string(args[0])
    desc = extract_string(args[1])
    kn = args[2]
    prob, wt, cost = args[3], args[4], args[5]
    hitbon = args[6]
    metal, sub, color = args[7], args[8], args[9]

    bits = (kn, "0", "1", "0", "0", "1", "0", "0", "0", "0", "0", sub, metal)
    return make_obj(name, desc, bits, "0", "WEAPON_CLASS", prob, "0", wt,
                    cost, "2", "2", hitbon, "0", wt, color)


def parse_armor(args):
    """ARMOR(name,desc,kn,mgc,blk,power,prob,delay,wt,cost,ac,can,sub,metal,c)"""
    if len(args) != 15:
        print(f"  WARNING: ARMOR has {len(args)} args: {args}", file=sys.stderr)
        return None
    name = extract_string(args[0])
    desc = extract_string(args[1])
    kn, mgc, blk = args[2], args[3], args[4]
    power = args[5]
    prob, delay, wt, cost = args[6], args[7], args[8], args[9]
    ac, can = args[10], args[11]
    sub, metal, c = args[12], args[13], args[14]

    ac_val = eval_int(ac)
    oc1 = 10 - ac_val

    bits = (kn, "0", "1", "0", mgc, "1", "0", "0", blk, "0", "0", sub, metal)
    return make_obj(name, desc, bits, power, "ARMOR_CLASS", prob, delay, wt,
                    cost, "0", "0", str(oc1), can, wt, c)


def parse_helm(args):
    """HELM(name,desc,kn,mgc,power,prob,delay,wt,cost,ac,can,metal,c)"""
    if len(args) != 13:
        print(f"  WARNING: HELM has {len(args)} args: {args}", file=sys.stderr)
        return None
    # HELM -> ARMOR with blk=0, sub=ARM_HELM
    name, desc, kn, mgc = args[0], args[1], args[2], args[3]
    power, prob, delay, wt, cost = args[4], args[5], args[6], args[7], args[8]
    ac, can, metal, c = args[9], args[10], args[11], args[12]
    return parse_armor([name, desc, kn, mgc, "0", power, prob, delay, wt, cost,
                        ac, can, "ARM_HELM", metal, c])


def parse_cloak(args):
    """CLOAK(name,desc,kn,mgc,power,prob,delay,wt,cost,ac,can,metal,c)"""
    if len(args) != 13:
        print(f"  WARNING: CLOAK has {len(args)} args: {args}", file=sys.stderr)
        return None
    name, desc, kn, mgc = args[0], args[1], args[2], args[3]
    power, prob, delay, wt, cost = args[4], args[5], args[6], args[7], args[8]
    ac, can, metal, c = args[9], args[10], args[11], args[12]
    return parse_armor([name, desc, kn, mgc, "0", power, prob, delay, wt, cost,
                        ac, can, "ARM_CLOAK", metal, c])


def parse_shield(args):
    """SHIELD(name,desc,kn,mgc,blk,power,prob,delay,wt,cost,ac,can,metal,c)"""
    if len(args) != 14:
        print(f"  WARNING: SHIELD has {len(args)} args: {args}", file=sys.stderr)
        return None
    name, desc, kn, mgc, blk = args[0], args[1], args[2], args[3], args[4]
    power, prob, delay, wt, cost = args[5], args[6], args[7], args[8], args[9]
    ac, can, metal, c = args[10], args[11], args[12], args[13]
    return parse_armor([name, desc, kn, mgc, blk, power, prob, delay, wt, cost,
                        ac, can, "ARM_SHIELD", metal, c])


def parse_gloves(args):
    """GLOVES(name,desc,kn,mgc,power,prob,delay,wt,cost,ac,can,metal,c)"""
    if len(args) != 13:
        print(f"  WARNING: GLOVES has {len(args)} args: {args}", file=sys.stderr)
        return None
    name, desc, kn, mgc = args[0], args[1], args[2], args[3]
    power, prob, delay, wt, cost = args[4], args[5], args[6], args[7], args[8]
    ac, can, metal, c = args[9], args[10], args[11], args[12]
    return parse_armor([name, desc, kn, mgc, "0", power, prob, delay, wt, cost,
                        ac, can, "ARM_GLOVES", metal, c])


def parse_boots(args):
    """BOOTS(name,desc,kn,mgc,power,prob,delay,wt,cost,ac,can,metal,c)"""
    if len(args) != 13:
        print(f"  WARNING: BOOTS has {len(args)} args: {args}", file=sys.stderr)
        return None
    name, desc, kn, mgc = args[0], args[1], args[2], args[3]
    power, prob, delay, wt, cost = args[4], args[5], args[6], args[7], args[8]
    ac, can, metal, c = args[9], args[10], args[11], args[12]
    return parse_armor([name, desc, kn, mgc, "0", power, prob, delay, wt, cost,
                        ac, can, "ARM_BOOTS", metal, c])


def parse_drgn_armr(args):
    """DRGN_ARMR(name,mgc,power,cost,ac,color)"""
    if len(args) != 6:
        print(f"  WARNING: DRGN_ARMR has {len(args)} args: {args}", file=sys.stderr)
        return None
    name = args[0]
    mgc, power, cost, ac, color = args[1], args[2], args[3], args[4], args[5]
    # ARMOR(name, None, 1, mgc, 1, power, 0, 5, 40, cost, ac, 0, ARM_SUIT, DRAGON_HIDE, color)
    return parse_armor([name, '"None"', "1", mgc, "1", power, "0", "5", "40", cost,
                        ac, "0", "ARM_SUIT", "DRAGON_HIDE", color])


def parse_ring(args):
    """RING(name,stone,power,cost,mgc,spec,mohs,metal,color)"""
    if len(args) != 9:
        print(f"  WARNING: RING has {len(args)} args: {args}", file=sys.stderr)
        return None
    name = extract_string(args[0])
    stone = extract_string(args[1])
    power = args[2]
    cost = args[3]
    mgc, spec = args[4], args[5]
    mohs = eval_int(args[6])
    metal, color = args[7], args[8]

    tuf = str(hardgem(mohs))
    bits = ("0", "0", spec, "0", mgc, spec, "0", "0", "0", tuf, "0", "P_NONE", metal)
    return make_obj(name, stone, bits, power, "RING_CLASS", "0", "0", "3",
                    cost, "0", "0", "0", "0", "15", color)


def parse_amulet(args):
    """AMULET(name,desc,power,prob)"""
    if len(args) != 4:
        print(f"  WARNING: AMULET has {len(args)} args: {args}", file=sys.stderr)
        return None
    name = extract_string(args[0])
    desc = extract_string(args[1])
    power, prob = args[2], args[3]

    bits = ("0", "0", "0", "0", "1", "0", "0", "0", "0", "0", "0", "P_NONE", "IRON")
    return make_obj(name, desc, bits, power, "AMULET_CLASS", prob, "0", "20",
                    "150", "0", "0", "0", "0", "20", "HI_METAL")


def parse_tool(args):
    """TOOL(name,desc,kn,mrg,mgc,chg,prob,wt,cost,mat,color)"""
    if len(args) != 11:
        print(f"  WARNING: TOOL has {len(args)} args: {args}", file=sys.stderr)
        return None
    name = extract_string(args[0])
    desc = extract_string(args[1])
    kn, mrg, mgc, chg = args[2], args[3], args[4], args[5]
    prob, wt, cost = args[6], args[7], args[8]
    mat, color = args[9], args[10]

    bits = (kn, mrg, chg, "0", mgc, chg, "0", "0", "0", "0", "0", "P_NONE", mat)
    return make_obj(name, desc, bits, "0", "TOOL_CLASS", prob, "0", wt,
                    cost, "0", "0", "0", "0", wt, color)


def parse_container(args):
    """CONTAINER(name,desc,kn,mgc,chg,prob,wt,cost,mat,color)"""
    if len(args) != 10:
        print(f"  WARNING: CONTAINER has {len(args)} args: {args}", file=sys.stderr)
        return None
    name = extract_string(args[0])
    desc = extract_string(args[1])
    kn, mgc, chg = args[2], args[3], args[4]
    prob, wt, cost = args[5], args[6], args[7]
    mat, color = args[8], args[9]

    bits = (kn, "0", chg, "1", mgc, chg, "0", "0", "0", "0", "0", "P_NONE", mat)
    return make_obj(name, desc, bits, "0", "TOOL_CLASS", prob, "0", wt,
                    cost, "0", "0", "0", "0", wt, color)


def parse_weptool(args):
    """WEPTOOL(name,desc,kn,mgc,bi,prob,wt,cost,sdam,ldam,hitbon,sub,mat,clr)"""
    if len(args) != 14:
        print(f"  WARNING: WEPTOOL has {len(args)} args: {args}", file=sys.stderr)
        return None
    name = extract_string(args[0])
    desc = extract_string(args[1])
    kn, mgc, bi = args[2], args[3], args[4]
    prob, wt, cost = args[5], args[6], args[7]
    sdam, ldam, hitbon = args[8], args[9], args[10]
    sub, mat, clr = args[11], args[12], args[13]

    bits = (kn, "0", "1", "0", mgc, "1", "0", "0", bi, "0", hitbon, sub, mat)
    return make_obj(name, desc, bits, "0", "TOOL_CLASS", prob, "0", wt,
                    cost, sdam, ldam, hitbon, "0", wt, clr)


def parse_food(args):
    """FOOD(name,prob,delay,wt,unk,tin,nutrition,color)"""
    if len(args) != 8:
        print(f"  WARNING: FOOD has {len(args)} args: {args}", file=sys.stderr)
        return None
    name = extract_string(args[0])
    prob = args[1]
    delay = args[2]
    wt = args[3]
    unk = args[4]
    tin = args[5]
    nutrition = eval_int(args[6])
    color = args[7]

    cost = nutrition // 20 + 5

    bits = ("1", "1", unk, "0", "0", "0", "0", "0", "0", "0", "0", "P_NONE", tin)
    return make_obj(name, None, bits, "0", "FOOD_CLASS", prob, delay, wt,
                    str(cost), "0", "0", "0", "0", str(nutrition), color)


def parse_potion(args):
    """POTION(name,desc,mgc,power,prob,cost,color)"""
    if len(args) != 7:
        print(f"  WARNING: POTION has {len(args)} args: {args}", file=sys.stderr)
        return None
    name = extract_string(args[0])
    desc = extract_string(args[1])
    mgc, power = args[2], args[3]
    prob, cost, color = args[4], args[5], args[6]

    bits = ("0", "1", "0", "0", mgc, "0", "0", "0", "0", "0", "0", "P_NONE", "GLASS")
    return make_obj(name, desc, bits, power, "POTION_CLASS", prob, "0", "20",
                    cost, "0", "0", "0", "0", "10", color)


def parse_scroll(args):
    """SCROLL(name,text,mgc,prob,cost)"""
    if len(args) != 5:
        print(f"  WARNING: SCROLL has {len(args)} args: {args}", file=sys.stderr)
        return None
    name = extract_string(args[0])
    text = extract_string(args[1])
    mgc = args[2]
    prob, cost = args[3], args[4]

    bits = ("0", "1", "0", "0", mgc, "0", "0", "0", "0", "0", "0", "P_NONE", "PAPER")
    return make_obj(name, text, bits, "0", "SCROLL_CLASS", prob, "0", "5",
                    cost, "0", "0", "0", "0", "6", "HI_PAPER")


def parse_spell(args):
    """SPELL(name,desc,sub,prob,delay,level,mgc,dir,color)"""
    if len(args) != 9:
        print(f"  WARNING: SPELL has {len(args)} args: {args}", file=sys.stderr)
        return None
    name = extract_string(args[0])
    desc = extract_string(args[1])
    sub = args[2]
    prob = args[3]
    delay = args[4]
    level = eval_int(args[5])
    mgc = args[6]
    d = args[7]
    color = args[8]

    cost = level * 100

    bits = ("0", "0", "0", "0", mgc, "0", "0", "0", "0", "0", d, sub, "PAPER")
    return make_obj(name, desc, bits, "0", "SPBOOK_CLASS", prob, delay, "50",
                    str(cost), "0", "0", "0", str(level), "20", color)


def parse_wand(args):
    """WAND(name,typ,prob,cost,mgc,dir,metal,color)"""
    if len(args) != 8:
        print(f"  WARNING: WAND has {len(args)} args: {args}", file=sys.stderr)
        return None
    name = extract_string(args[0])
    typ = extract_string(args[1])
    prob, cost, mgc = args[2], args[3], args[4]
    d, metal, color = args[5], args[6], args[7]

    bits = ("0", "0", "1", "0", mgc, "1", "0", "0", "0", "0", d, "P_NONE", metal)
    return make_obj(name, typ, bits, "0", "WAND_CLASS", prob, "0", "7",
                    cost, "0", "0", "0", "0", "30", color)


def parse_coin(args):
    """COIN(name,prob,metal,worth)"""
    if len(args) != 4:
        print(f"  WARNING: COIN has {len(args)} args: {args}", file=sys.stderr)
        return None
    name = extract_string(args[0])
    prob, metal, worth = args[1], args[2], args[3]

    bits = ("0", "1", "0", "0", "0", "0", "0", "0", "0", "0", "0", "P_NONE", metal)
    return make_obj(name, None, bits, "0", "COIN_CLASS", prob, "0", "1",
                    worth, "0", "0", "0", "0", "0", "HI_GOLD")


def parse_gem(args):
    """GEM(name,desc,prob,wt,gval,nutr,mohs,glass,color)"""
    if len(args) != 9:
        print(f"  WARNING: GEM has {len(args)} args: {args}", file=sys.stderr)
        return None
    name = extract_string(args[0])
    desc = extract_string(args[1])
    prob = args[2]
    wt = args[3]
    gval = args[4]
    nutr = args[5]
    mohs = eval_int(args[6])
    glass, color = args[7], args[8]

    tuf = str(hardgem(mohs))
    bits = ("0", "1", "0", "0", "0", "0", "0", "0", "0", tuf, "0", "-P_SLING", glass)
    return make_obj(name, desc, bits, "0", "GEM_CLASS", prob, "0", "1",
                    gval, "3", "3", "0", "0", nutr, color)


def parse_rock(args):
    """ROCK(name,desc,kn,prob,wt,gval,sdam,ldam,mgc,nutr,mohs,glass,color)"""
    if len(args) != 13:
        print(f"  WARNING: ROCK has {len(args)} args: {args}", file=sys.stderr)
        return None
    name = extract_string(args[0])
    desc = extract_string(args[1])
    kn = args[2]
    prob = args[3]
    wt = args[4]
    gval = args[5]
    sdam, ldam = args[6], args[7]
    mgc = args[8]
    nutr = args[9]
    mohs = eval_int(args[10])
    glass, color = args[11], args[12]

    tuf = str(hardgem(mohs))
    bits = (kn, "1", "0", "0", mgc, "0", "0", "0", "0", tuf, "0", "-P_SLING", glass)
    return make_obj(name, desc, bits, "0", "GEM_CLASS", prob, "0", wt,
                    gval, sdam, ldam, "0", "0", nutr, color)


def extract_objects(text):
    """Parse all object macro calls from preprocessed objects.c text.

    Handles the special '#define PAPER LEATHER' for dig/magic missile spells
    by tracking where the SPELL calls appear relative to the undef.
    """
    # Known object macros in order of definition in objects.c
    obj_macros = [
        "OBJECT", "PROJECTILE", "WEAPON", "BOW",
        "ARMOR", "HELM", "CLOAK", "SHIELD", "GLOVES", "BOOTS", "DRGN_ARMR",
        "RING", "AMULET",
        "TOOL", "CONTAINER", "WEPTOOL",
        "FOOD",
        "POTION",
        "SCROLL",
        "SPELL",
        "WAND",
        "COIN",
        "GEM", "ROCK",
    ]

    # Find all macro calls with their positions
    all_calls = []
    for macro in obj_macros:
        pattern = re.compile(r'\b' + re.escape(macro) + r'\s*\(')
        pos = 0
        while pos < len(text):
            m = pattern.search(text, pos)
            if not m:
                break
            # Make sure it's not part of a #define
            # Check the line this appears on
            line_start = text.rfind('\n', 0, m.start()) + 1
            line_prefix = text[line_start:m.start()].strip()
            if line_prefix.startswith('#'):
                pos = m.end()
                continue
            paren_start = m.end() - 1
            paren_end = find_matching_paren(text, paren_start)
            if paren_end < 0:
                pos = m.end()
                continue
            inner = normalize_ws(text[paren_start + 1:paren_end])
            all_calls.append((m.start(), macro, inner))
            pos = paren_end + 1

    # Sort by position in file
    all_calls.sort(key=lambda x: x[0])

    objects = []
    # Track the "dig" and "magic missile" spells which use PAPER=LEATHER
    paper_leather_spells = {"dig", "magic missile"}

    for _pos, macro, inner in all_calls:
        args = split_args(inner)
        obj = parse_obj_macro(macro, inner, text)
        if obj is None:
            continue

        # Handle the PAPER -> LEATHER substitution for dig and magic missile spells
        if macro == "SPELL" and obj['name'] in paper_leather_spells:
            obj['material'] = "LEATHER"

        objects.append(obj)

    return objects


# ============================================================================
# Rust code generation
# ============================================================================

def alignment_variant(val):
    """Map alignment integer to Rust Alignment variant."""
    if val < 0:
        return "Chaotic"
    elif val > 0:
        return "Lawful"
    else:
        return "Neutral"


def color_variant(color_str):
    """Map a color constant to Rust Color variant."""
    color_str = color_str.strip()
    # Handle C(color) wrapper
    m = re.match(r'^C\s*\((.+)\)$', color_str)
    if m:
        color_str = m.group(1).strip()
    if color_str in COLOR_MAP:
        return COLOR_MAP[color_str]
    # Try numeric
    try:
        val = int(color_str)
        num_map = {
            0: "Black", 1: "Red", 2: "Green", 3: "Brown", 4: "Blue",
            5: "Magenta", 6: "Cyan", 7: "Gray", 8: "NoColor",
            9: "Orange", 10: "BrightGreen", 11: "Yellow",
            12: "BrightBlue", 13: "BrightMagenta", 14: "BrightCyan", 15: "White",
        }
        return num_map.get(val, "Black")
    except ValueError:
        print(f"  WARNING: Unknown color '{color_str}'", file=sys.stderr)
        return "Black"


def material_variant(mat_str):
    """Map a material constant to Rust Material variant."""
    mat_str = mat_str.strip()
    if mat_str in MATERIAL_MAP:
        return MATERIAL_MAP[mat_str]
    try:
        val = int(mat_str)
        if val == 0:
            return "Liquid"
        return "Liquid"
    except ValueError:
        print(f"  WARNING: Unknown material '{mat_str}'", file=sys.stderr)
        return "Liquid"


def objclass_variant(cls_str):
    """Map an object class constant to Rust ObjectClass variant."""
    cls_str = cls_str.strip()
    if cls_str in OBJCLASS_MAP:
        return OBJCLASS_MAP[cls_str]
    print(f"  WARNING: Unknown object class '{cls_str}'", file=sys.stderr)
    return "IllObj"


def format_attack(atk):
    """Format a single attack as Rust code."""
    if atk is None:
        return "Attack::NONE"
    at_str, ad_str, n, d = atk
    at_rust = AT_MAP.get(at_str, "None")
    ad_rust = AD_MAP.get(ad_str, "Physical")
    return f"Attack::new(AttackType::{at_rust}, DamageType::{ad_rust}, {n}, {d})"


def format_resistance(val):
    """Format resistance flags as Rust code."""
    if val == 0:
        return "Resistance::empty()"
    return f"Resistance::from_bits_truncate(0x{val:02X})"


def format_m1(val):
    """Format M1 flags as Rust code."""
    if val == 0:
        return "MonsterFlags1::empty()"
    return f"MonsterFlags1::from_bits_truncate(0x{val:08X})"


def format_m2(val):
    """Format M2 flags as Rust code."""
    if val == 0:
        return "MonsterFlags2::empty()"
    return f"MonsterFlags2::from_bits_truncate(0x{val:08X})"


def format_m3(val):
    """Format M3 flags as Rust code."""
    if val == 0:
        return "MonsterFlags3::empty()"
    return f"MonsterFlags3::from_bits_truncate(0x{val:04X})"


def format_geno(val):
    """Format geno flags as Rust code."""
    return f"GenoFlags::from_bits_truncate(0x{val:04X})"


def write_monster_id(monsters, path):
    """Write the MonsterId enum file."""
    # Use symbol as class hint for deduplication (@ = Human, matching C PM_HUMAN_*)
    sym_hint = {
        "@": "Human",
    }
    names = deduplicate_names([
        (m['name'], sym_hint.get(S_SYMBOL_MAP.get(m['symbol'], ''), ''))
        for m in monsters
    ])
    with open(path, 'w') as f:
        f.write(GENERATED_HEADER)
        f.write("\n")
        f.write("use serde::Serialize;\n")
        f.write("use strum::{EnumCount, EnumIter, FromRepr};\n")
        f.write("\n")
        f.write("#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Serialize, EnumIter, EnumCount, FromRepr)]\n")
        f.write("#[repr(u16)]\n")
        f.write("pub enum MonsterId {\n")
        for i, name in enumerate(names):
            f.write(f"    {name} = {i},\n")
        f.write("}\n")
        f.write("\n")
        f.write("impl MonsterId {\n")
        f.write(f"    pub const NUM_MONSTERS: usize = {len(monsters)};\n")
        f.write("}\n")


def write_object_id(objects, path):
    """Write the ObjectId enum file."""
    # Build name-class pairs for deduplication
    class_prefixes = {
        "Scroll": "ScrollOf", "SpellBook": "SpellOf", "Wand": "WandOf",
        "Potion": "PotionOf", "Ring": "RingOf", "Tool": "Tool",
    }

    names_ctx = []
    for obj in objects:
        name = obj['name']
        cls = objclass_variant(obj['class'])
        if name is None:
            # Use description-based name
            desc = obj.get('description', '')
            if desc:
                prefix_map = {
                    "Scroll": "Scroll", "Wand": "Wand", "SpellBook": "SpellBook",
                }
                prefix = prefix_map.get(cls, cls)
                name = f"{prefix} {desc}"
            else:
                name = f"Unknown{cls}"
        names_ctx.append((name, class_prefixes.get(cls, "")))

    names = deduplicate_names(names_ctx)

    with open(path, 'w') as f:
        f.write(GENERATED_HEADER)
        f.write("\n")
        f.write("use serde::Serialize;\n")
        f.write("use strum::{EnumCount, EnumIter, FromRepr};\n")
        f.write("\n")
        f.write("#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Serialize, EnumIter, EnumCount, FromRepr)]\n")
        f.write("#[repr(u16)]\n")
        f.write("pub enum ObjectId {\n")
        for i, name in enumerate(names):
            f.write(f"    {name} = {i},\n")
        f.write("}\n")
        f.write("\n")
        f.write("impl ObjectId {\n")
        f.write(f"    pub const NUM_OBJECTS: usize = {len(objects)};\n")
        f.write("}\n")


def write_monsters_rs(monsters, path):
    """Write the monsters.rs data file."""
    n = len(monsters)
    with open(path, 'w') as f:
        f.write(GENERATED_HEADER)
        f.write("\n")
        f.write("#![allow(clippy::unreadable_literal)]\n")
        f.write("\n")
        f.write("use nethack_types::*;\n")
        f.write("\n")
        f.write(f"pub static MONSTERS: [MonsterType; {n}] = [\n")
        for mon in monsters:
            sym = S_SYMBOL_MAP.get(mon['symbol'], '?')
            # Escape single quote for Rust char literal
            if sym == "'":
                sym_lit = "'\\''"
            elif sym == '\\':
                sym_lit = "'\\\\'"
            else:
                sym_lit = f"'{sym}'"

            attacks_str = ", ".join(format_attack(a) for a in mon['attacks'])
            align = alignment_variant(mon['alignment'])
            color = color_variant(mon['color'])
            sound = MS_MAP.get(mon['sound'], 'Silent')
            size = MZ_MAP.get(mon['size'], 'Medium')

            f.write("    MonsterType {\n")
            f.write(f'        name: "{mon["name"]}",\n')
            f.write(f'        symbol: {sym_lit},\n')
            f.write(f'        level: {mon["level"]},\n')
            f.write(f'        move_speed: {mon["move_speed"]},\n')
            f.write(f'        ac: {mon["ac"]},\n')
            f.write(f'        magic_resistance: {mon["magic_resistance"]},\n')
            f.write(f'        alignment: Alignment::{align},\n')
            f.write(f'        geno: {format_geno(mon["geno"])},\n')
            f.write(f'        attacks: [{attacks_str}],\n')
            f.write(f'        corpse_weight: {mon["corpse_weight"]},\n')
            f.write(f'        nutrition: {mon["nutrition"]},\n')
            f.write(f'        sound: MonsterSound::{sound},\n')
            f.write(f'        size: MonsterSize::{size},\n')
            f.write(f'        resistances: {format_resistance(mon["resistances"])},\n')
            f.write(f'        conveys: {format_resistance(mon["conveys"])},\n')
            f.write(f'        flags1: {format_m1(mon["flags1"])},\n')
            f.write(f'        flags2: {format_m2(mon["flags2"])},\n')
            f.write(f'        flags3: {format_m3(mon["flags3"])},\n')
            f.write(f'        difficulty: {mon["difficulty"]},\n')
            f.write(f'        color: Color::{color},\n')
            f.write("    },\n")
        f.write("];\n")


def write_objects_rs(objects, path):
    """Write the objects.rs data file."""
    n = len(objects)
    with open(path, 'w') as f:
        f.write(GENERATED_HEADER)
        f.write("\n")
        f.write("#![allow(clippy::unreadable_literal)]\n")
        f.write("\n")
        f.write("use nethack_types::*;\n")
        f.write("\n")
        f.write(f"pub static OBJECTS: [ObjectType; {n}] = [\n")
        for obj in objects:
            name = obj['name'] if obj['name'] else ""
            desc = obj['description']
            cls = objclass_variant(obj['class'])
            mat = material_variant(obj['material'])
            color = color_variant(obj['color'])
            flags = obj['flags']

            desc_str = f'Some("{desc}")' if desc else "None"

            f.write("    ObjectType {\n")
            f.write(f'        name: "{name}",\n')
            f.write(f'        description: {desc_str},\n')
            f.write(f'        class: ObjectClass::{cls},\n')
            f.write(f'        sub_type: {obj["sub_type"]},\n')
            f.write(f'        prob: {obj["prob"]},\n')
            f.write(f'        delay: {obj["delay"]},\n')
            f.write(f'        weight: {obj["weight"]},\n')
            f.write(f'        cost: {obj["cost"]},\n')
            f.write(f'        damage_small: {obj["damage_small"]},\n')
            f.write(f'        damage_large: {obj["damage_large"]},\n')
            f.write(f'        oc1: {obj["oc1"]},\n')
            f.write(f'        oc2: {obj["oc2"]},\n')
            f.write(f'        material: Material::{mat},\n')
            f.write(f'        color: Color::{color},\n')
            f.write(f'        nutrition: {obj["nutrition"]},\n')
            f.write(f'        prop: {obj["prop"]},\n')
            f.write("        flags: ObjectTypeFlags {\n")
            f.write(f'            name_known: {"true" if flags["name_known"] else "false"},\n')
            f.write(f'            merge: {"true" if flags["merge"] else "false"},\n')
            f.write(f'            uses_known: {"true" if flags["uses_known"] else "false"},\n')
            f.write(f'            pre_discovered: {"true" if flags["pre_discovered"] else "false"},\n')
            f.write(f'            magic: {"true" if flags["magic"] else "false"},\n')
            f.write(f'            charged: {"true" if flags["charged"] else "false"},\n')
            f.write(f'            unique: {"true" if flags["unique"] else "false"},\n')
            f.write(f'            no_wish: {"true" if flags["no_wish"] else "false"},\n')
            f.write(f'            big: {"true" if flags["big"] else "false"},\n')
            f.write(f'            tough: {"true" if flags["tough"] else "false"},\n')
            f.write(f'            dir: {flags["dir"]},\n')
            f.write("        },\n")
            f.write("    },\n")
        f.write("];\n")


# ============================================================================
# Main
# ============================================================================

def main():
    parser = argparse.ArgumentParser(description="Extract NetHack data into Rust source")
    parser.add_argument("--root", type=Path, default=None,
                        help="Project root directory (default: auto-detect)")
    args = parser.parse_args()

    if args.root:
        root = args.root
    else:
        root = Path(__file__).resolve().parent.parent

    monst_c = root / "nethack" / "src" / "monst.c"
    objects_c = root / "nethack" / "src" / "objects.c"

    if not monst_c.exists():
        print(f"ERROR: {monst_c} not found", file=sys.stderr)
        sys.exit(1)
    if not objects_c.exists():
        print(f"ERROR: {objects_c} not found", file=sys.stderr)
        sys.exit(1)

    # Parse monsters
    print("Parsing monsters...")
    monst_text = monst_c.read_text()
    monst_text = preprocess(monst_text)
    monsters = parse_monsters(monst_text)
    print(f"Found {len(monsters)} monsters")

    # Parse objects
    print("Parsing objects...")
    obj_text = objects_c.read_text()
    obj_text = preprocess(obj_text)
    objects = extract_objects(obj_text)
    print(f"Found {len(objects)} objects")

    # Validate counts
    if len(monsters) != 382:
        print(f"WARNING: Expected 382 monsters, got {len(monsters)}", file=sys.stderr)
    if len(objects) != 454:
        print(f"WARNING: Expected 454 objects, got {len(objects)}", file=sys.stderr)

    # Write output files
    types_dir = root / "crates" / "nethack-types" / "src"
    data_dir = root / "crates" / "nethack-data" / "src"

    write_monster_id(monsters, types_dir / "monster_id.rs")
    print(f"Wrote {types_dir / 'monster_id.rs'}")

    write_object_id(objects, types_dir / "object_id.rs")
    print(f"Wrote {types_dir / 'object_id.rs'}")

    write_monsters_rs(monsters, data_dir / "monsters.rs")
    print(f"Wrote {data_dir / 'monsters.rs'}")

    write_objects_rs(objects, data_dir / "objects.rs")
    print(f"Wrote {data_dir / 'objects.rs'}")

    print("Done!")


if __name__ == "__main__":
    main()
